---
title: "[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤] Lv.3 ë‹¨ì–´ ë³€í™˜ - Python"
date: 2025-01-13  
categories: [ì½”ë”©í…ŒìŠ¤íŠ¸ ì—°ìŠµ, í”„ë¡œê·¸ë˜ë¨¸ìŠ¤]
tags: [Python, Algorithm]
layout: post
author: mongblang
---

# ğŸ“Œ&nbsp; **ë‹¨ì–´ ë³€í™˜**
[ë¬¸ì œ ë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/43163)  

# ğŸ“&nbsp; **ë¬¸ì œ**
---
![ë¬¸ì œ](/assets/img/codingtest-post-img/PG43163-1.png)

## âœï¸&nbsp; **ì…ì¶œë ¥ ì˜ˆì‹œ**
---
![ì˜ˆì‹œ](/assets/img/codingtest-post-img/PG43163-2.png)


&nbsp;  

&nbsp;   



## **ë‚´ í’€ì´**  
--- 

```python
from collections import deque

def solution(begin, target, words):
    queue = deque([(begin,0)])
    visited = set()

    while queue:
        cur_word, steps = queue.popleft()
        
        if cur_word == target:
            return steps
        
        for next_word in words:
            cnt = 0
            for i in range(len(cur_word)):
                if cur_word[i] != next_word[i]:
                    cnt += 1
            if cnt == 1 and next_word not in visited:
                queue.append((next_word, steps + 1))
                visited.add(next_word)
    return 0
```


#### **ì½”ë“œ í•´ì„¤**  
1. ë±ì— ì²˜ìŒ ì‹œì‘ ë‹¨ì–´ `begin`ê³¼ target ê¹Œì§€ì˜ ë‹¨ê³„ë¥¼ ê³„ì‚°í•  ìˆ˜ 0ì„ íŠœí”Œí˜•íƒœë¡œ ì €ì¥í•œë‹¤.
2. ë°©ë¬¸ì²˜ë¦¬ë¥¼ í•  ì§‘í•© `visited`ë¥¼ ìƒì„±í•œë‹¤.
3. íì— ì›ì†Œê°€ ì—†ì„ë•Œê¹Œì§€ ì•„ë˜ ì‘ì—…ì„ ë°˜ë³µí•œë‹¤.
4. ë±ì—ì„œ í˜„ì¬ ë‹¨ì–´`cur_word`ì™€ ë‹¨ê³„ ìˆ˜ `steps`ë¥¼ êº¼ë‚´ í• ë‹¹í•œë‹¤.
5. ì¢…ë£Œ ì¡°ê±´ ì„¤ì • - ë§Œì•½ í˜„ì¬ ë‹¨ì–´ê°€ íƒ€ê²Ÿê³¼ ì¼ì¹˜í•˜ë©´ ë‹¨ê³„ ìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤.
6. `words`ë¦¬ìŠ¤íŠ¸ì˜ ê° ë‹¨ì–´ë¥¼ ìˆœíšŒí•˜ë©° (íƒìƒ‰í•  ë‹¨ì–´) ì•ŒíŒŒë²³ì„ ë¹„êµí•  ë³€ìˆ˜ `cnt`ë¥¼ ì´ˆê¸°í™” í•œë‹¤.
7. ê° ë‹¨ì–´ì˜ ì•ŒíŒŒë²³ì„ ìˆœíšŒí•˜ë©° í˜„ì¬ ë‹¨ì–´ì˜ ê° ì•ŒíŒŒë²³ê³¼ ë‹¤ìŒ ë‹¨ì–´ì˜ ì•ŒíŒŒë²³ì´ ë‹¤ë¥´ë©´ ì¹´ìš´íŠ¸ë¥¼ 1ì”© ì˜¬ë¦°ë‹¤. 
8. ì•ŒíŒŒë²³ì´ í•˜ë‚˜ë§Œ ë‹¤ë¥´ê³ (cnt=1), ë‹¤ìŒ ë‹¨ì–´ê°€ ì•„ì§ íƒìƒ‰í•˜ì§€ ì•Šì€ ë‹¨ì–´ì¼ ê²½ìš° ë±ì— ì¶”ê°€í•˜ê³  stepsë¥¼ 1 ë”í•œë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ í•´ë‹¹ ë‹¨ì–´ë¥¼ ë°©ë¬¸ì²˜ë¦¬í•œë‹¤. 
9. íƒìƒ‰ì´ ì¢…ë£Œëì„ë•Œê¹Œì§€ ì¢…ë£Œì¡°ê±´ì— ê±¸ë¦¬ì§€ ì•Šì€ ê²½ìš°, ì¦‰, íƒ€ê²Ÿë‹¨ì–´ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ëŠ” ê²½ìš° 0ì„ ë°˜í™˜í•œë‹¤.  

&nbsp;  

## **ë‹¤ë¥¸ í’€ì´**
---

```python  
from collections import deque

def get_adjacent(current, words):
    for word in words:
        if len(current) != len(word):
            continue

        count = 0
        for c, w in zip(current, word):
            if c != w:
                count += 1

        if count == 1:
            yield word


def solution(begin, target, words):
    dist = {begin: 0}
    queue = deque([begin])

    while queue:
        current = queue.popleft()

        for next_word in get_adjacent(current, words):
            if next_word not in dist:
                dist[next_word] = dist[current] + 1
                queue.append(next_word)

    return dist.get(target, 0)
```

#### **ì½”ë“œ í•´ì„¤**  
1. `words` ë¦¬ìŠ¤íŠ¸ì˜ ë‹¨ì–´ë¥¼ ìˆœíšŒí•˜ë©° í˜„ì¬ ë‹¨ì–´ì™€ ë¹„êµí•  ë‹¨ì–´ì˜ ê¸¸ì´ê°€ ë‹¤ë¥¸ ê²½ìš° ë„˜ì–´ê°„ë‹¤.
2. ë‘ ë‹¨ì–´ë¥¼ zipìœ¼ë¡œ ë¬¶ì–´ ë™ì‹œì— ë¹„êµí•˜ê³  ê° ì•ŒíŒŒë²³ì´ ë‹¤ë¥¸ ê²½ìš° `count`ë¥¼ 1ì”© ì¦ê°€ì‹œí‚¨ë‹¤. 
3. `count`ê°€ 1ì¸ ê²½ìš° í•´ë‹¹ ë‹¨ì–´ë¥¼ ë°˜í™˜í•œë‹¤. yieldë¥¼ ì‚¬ìš©í•˜ë©´ ë¦¬ìŠ¤íŠ¸ë¥¼ ë¯¸ë¦¬ ë§Œë“¤ì§€ ì•Šê³  í•„ìš”í•  ë•Œ ë‹¨ì–´ë¥¼ í•˜ë‚˜ì”© ìƒì„±í•  ìˆ˜ ìˆë‹¤. 
4. ë‹¨ì–´ë³„ ìµœë‹¨ ê±°ë¦¬ë¥¼ ì €ì¥í•˜ëŠ” ë”•ì…”ë„ˆë¦¬ `dist`ë¥¼ ì •ì˜í•´ ê±°ë¦¬ ê³„ì‚°ê³¼ ë°©ë¬¸ì—¬ë¶€ë¥¼ ë™ì‹œì— ê´€ë¦¬í•œë‹¤.
5. ë±ì— ì‹œì‘ ë‹¨ì–´ë¥¼ ë„£ê³  ë°˜ë³µí•˜ë©° `current`ì—ì„œ í•œ ë‹¨ê³„ ë§Œì— ê°ˆ ìˆ˜ ìˆëŠ” ëª¨ë“  ë‹¨ì–´ë¥¼ í™•ì¸í•œë‹¤.
6. ë§Œì•½ ë‹¤ìŒ ë‹¨ì–´ê°€ `dist`ì— ì—†ëŠ” ê²½ìš° í•´ë‹¹ ë‹¨ì–´ë¥¼ ë„£ì–´ ë°©ë¬¸ì²˜ë¦¬í•˜ê³  í˜„ì¬ ë‹¨ì–´ì˜ ê±°ë¦¬ë¥¼ 1 ì¦ê°€ì‹œí‚¨ë‹¤.
7. `get` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ íƒ€ê²Ÿ ë‹¨ì–´ê°€ `dist`ì— ì—†ëŠ” ê²½ìš° 0ì„ ë°˜í™˜í•˜ê³ , ìˆëŠ” ê²½ìš° í•´ë‹¹ ë‹¨ì–´ì˜ ê°’ì„ ë°˜í™˜í•œë‹¤. 



&nbsp;   
&nbsp;  
