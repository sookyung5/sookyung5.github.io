---
title: "[알고리즘] 트리 - Python"
date: 2025-01-08  
categories: [코딩테스트 연습, 알고리즘 공부]
tags: [Python, Algorithm]
layout: post
author: mongblang
---

## **트리**
- 데이터를 저장하고 탐색하는데 유용하게 사용되는 계층 구조를 표현하는 방법
    - **노드(node)**: 트리를 구성하는 요소. 가장 위에 있는 노드는 루트 노드라고 한다. 
        - **부모 노드**: 자식 노드 위에 있는 노드
        - **자식 노드**: 부모 노드 아래에 있는 노드
        - **리프/말단 노드**: 자식이 없는 노드 
    - **에지(edge)**: 노드와 노드를 잇는 선으로, 간선이라고도 한다. 간선으로 연결된 노드들은 서로 부모-자식관계이다. 
        - **차수(degree)**: 특정 노드에서 아래로 향하는 간선의 개수 
    - **레벨**: 루트 노드로부터 특정 노드까지 거쳐가는 최소한의 간선 수

> **주의사항**  
노드 삭제시 자식 노드보다 부모 노드를 먼저 삭제하면 재귀로 루트 노트까지 삭제될 수 있으므로 자식 노드를 먼저 삭제해야 함
{: .prompt-warning }

&nbsp;  

---

## **1. 이진 트리**
모든 노드의 최대 차수가 2를 넘지 않는 트리(= 간선이 최대 2개인 트리)로, 노드 하나가 최대 2개의 자식 노드를 가짐 

![tree1](/assets/img/codingtest-post-img/AL_tree-1.png)

&nbsp;  

### **1-2. 이진 트리 순회 방법**
- 전위 순회 (preorder): 현재 노드를 부모 노드라고 했을 때, 부모 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드 순 (중-왼-오)
    ![tree2](/assets/img/codingtest-post-img/AL_tree-2.png)
    1 - 4 - 3 - 2 - 5 -8 - 1 순으로 방문  
    &nbsp;  
    - 코드 구현
    ```python
    def preorder(nodes,idx):
    # idx가 노드 리스트의 길이보다 작을 때 
        if idx < len(nodes):
            # 루트 노드 출력 -> 왼쪽 서브트리와 오른쪽 서브 트리를 재귀호출하며 출력 순서대로 이어붙임
            ret = str(nodes[idx]) + " "
            ret += preorder(nodes, idx * 2 + 1) # 인덱스가 0부터 시작하기 때문에 왼쪽 노드 + 1 오른쪽 +2 해줌 
            ret += preorder(nodes, idx * 2 + 2)
            return ret
        # idx >= len(nodes)일때는 빈 문자열 반환
        else:
            return ""
    ```
      
    &nbsp; 

- 중위 순회 (inorder): 현재 노드를 부모 노드라고 했을 때, 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드 순 (왼-중-오)
    ![tree3](/assets/img/codingtest-post-img/AL_tree-3.png)
    2 - 3 - 4 - 5 - 1 - 8 - 6 - 7 순으로 방문 (왼쪽 자식노드를 우선시 해야하기 때문에 왼쪽 리프 노드 방문하기 전 까지 위 레벨의 부모노드들은 지나쳐감)  
    &nbsp;  
    - 코드 구현
    ```python
    def inorder(nodes, idx):
        # idx가 노드 리스트의 길이보다 작을 때
        if idx < len(nodes):
            # 왼쪽 서브트리 먼저 재귀 호출해서 이어붙임
            ret = inorder(nodes, idx * 2 + 1)
            # 루트 노드 출력 후 오른쪽 서브트리 재귀호출 
            ret += str(nodes[idx]) + " "
            ret += inorder(nodes, idx * 2 + 2)
            return ret
        else:
            return ""
    ```
    &nbsp;  
- 후위 순회 (postorder): 현재 노드를 부모 노드라고 했을 때, 왼쪽 자식 노드 -> 오른쪽 자식 노드 -> 부모 노드 순
    ![tree4](/assets/img/codingtest-post-img/AL_tree-4.png)
    2 - 3 - 5 - 4 - 6 - 7 - 8 - 1 순으로 방문 (왼쪽 방문 후 오른쪽 방문한 다음 부모노드 방문)  
    &nbsp;  
    - 코드 구현
    ```python
    def postorder(nodes,idx):
        if idx < len(nodes):
            ret = postorder(nodes, idx * 2 + 1)
            ret += postorder(nodes, idx * 2 + 2)
            ret += str(nodes[idx]) + " "
            return ret
        else:
            return ""
    ```
    &nbsp;  

### **1-3. 이진 트리 탐색**
- 이진 탐색 트리: 데이터 크기가 작으면 왼쪽 자식 노드, 크거나 같으면 오른쪽 자식 노드에 배치된 구조를 가짐
    - 데이터 크기에 따라 한 쪽을 검색 대상에서 제외하므로 탐색 시간이 빠름 
- 균형 이진 탐색 트리: 노드가 한 쪽으로 치우쳐져 있지 않고 왼쪽과 오른쪽 서브 트리의 높이 차가 1 이하인 트리로, O(logN)의 시간 복잡도를 가짐 

#### **1-3-1. 탐색 방법**
1. 찾으려는 값과 현재 노드의 값이 같으면 탐색 종료, 크면 오른쪽 노드 탐색
2. 찾으려는 값이 현재 노드보다 작으면 왼쪽 노드 탐색
3. 값을 찾았다면 종료. 

&nbsp;  

---

### **2. 배열로 트리 구현**
루트 노드의 인덱스를 1이라고 했을 때, 
- 왼쪽 자식 노드의 인덱스는 `부모 노드의 인덱스 * 2`
- 오른쪽 자식 노드의 인덱스는 `(부모 노드의 인덱스 * 2) + 1` 이다. 
- 이진 트리의 균형이 맞지 않는 경우, 두 자료구조의 시간복잡도가 O(N)으로 같음

&nbsp;  

---

## **3. 포인터로 트리 구현**
- 노드 값 양쪽에 왼쪽 자식노드와 오른쪽 자식노드로 구성됨
- 인덱스 연산을 하지 않으므로 메모리 낭비가 없지만, 구현 난이도는 배열보다 높음 
    ![tree5](/assets/img/codingtest-post-img/AL_tree-5.png)

&nbsp;  

---
